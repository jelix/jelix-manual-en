~~LANG:FR@frman:composants/daos/fichier_de_base~~

In order to use jDao, you have to write an XML file which describes the mapping,
i.e, which properties of a jDao record correspond to which field in a SQL table.

===== Creating a file automatically =====

A DAO file can be generated by the jelix script on the command line, from an existing table.

<code bash>
 php dev.php module:create-dao <modulename> <daoname> [<tablename> [<sequencename>]]
</code>

For example, if you want to create a "product" dao from the table "shop_product"
in the "myshop" module, you will enter:

<code bash>
  php dev.php module:create-dao myshop product shop_product
</code>

In the @@F@daos@@ directory of the //myshop// module, you will have then a
@@F@product.dao.xml@@ file which contain the mapping description. The table name
is optional if you want to use the table name for the dao name, and if you don't
have a sequence. You can indicate the name of the sequence used to auto
increment the primary key (oracle databases and pgsql).

The automatic generation of a dao file helps to create quickly, but you will
have often to modify this files to customize the mapping, to add method
declaration etc..

===== Details on the XML format =====

<code xml>
<dao xmlns="http://jelix.org/ns/dao/1.0">
   <datasources>
     datasources section
   </datasources>
   <record>
      properties section
   </record>
   <factory>
      methods section
   </factory>
</dao>
</code>

There are three sections, although the @@E@<factory>@@ section is optional. This
section is described [[xml_methods|in an other chapter]].

  * @@E@<datasources>@@ : defines the tables on which the object will be mapped.
  * @@E@<record>@@ : defines the mapping itself.

===== Simple mapping =====

==== Table declaration ==== 

We call simple mapping, a mapping where a record is mapped to a single table. To
declare the table, we use the tag @@E@<primarytable>@@ with the following
attributes:

   * @@A@name@@: alias given to the table and that will be used in SQL queries
   * @@A@realname@@ (optional): real name of the table in the database. If this
     attribute is not specified, it takes the same value as the attribute
     @@A@name@@. In this case @@A@name@@ must contain the real name of the
     table.
   * @@A@primarykey@@ indicates the primary key. You can specify multiple
     fields, separated by a space or a comma.


<code xml>
  <datasources>
      <primarytable name="p" realname="products" primarykey="id_product" />
  </datasources>
</code>


It says here that the record will be based on the table @@products@@, which has
the alias @@p@@, and which contains the primary key @@id_product@@.

There is always a single table "primary" in a DAO (hence a single tag
@@E@<primarytable>@@). You will see that you can specify other tables (foreign
tables) farther.

Then we should declare the mapping between the record fields and the object properties.

==== Properties declaration ====

The @@E@<record>@@ section declares the properties of an object @@record@@. Each
property corresponds to a field in the primary table, or one of those foreign
tables as you will see later. Of course, you are not obliged to declare a
property for all existing fields. We can make several DAO working on the same
table but which are intended for different uses. For example make a specific DAO
to recover slight registration lists (so the mapping is made on the essential
properties), and an other to manage full datas (so the mapping is made on all
fields).

The @@E@<record>@@ section must contain one or more @@E@<property>@@ element.
Here is the @@E@<property>@@ element with possible attributes:

<code xml>
  <property 
      name="simplificated name" 
      fieldname="filed name" 
      datatype="" required="true/false" minlength="" maxlength="" regexp="" 
      sequence="sequence name" autoincrement="true/false"
      updatepattern="" insertpattern="" selectpattern=""
      default="" comment=""
   />
</code>

The attribute @@A@name@@ is the name of the property of the object.

The attribute @@A@fieldname@@ is the field name on which the property is mapped.
If @@A@name@@ and @@A@fieldname@@ are equals, we can leave @@A@fieldname@@.

The attributes @@A@datatype@@, @@A@required@@, @@A@minlength@@, @@A@maxlength@@
and @@A@regexp@@ are constraints. This allows the @@M@check()@@ method to verify
the values of properties (before storage for instance).

The attribute @@A@default@@ allows you to specify a default value which will be
stored in the property.

The attribute @@A@datatype@@ indicates the type of the field. Here is the list
of recognized types. You can see that there are many more types than in previous
jelix version:

  * @@varchar@@, @@varchar2@@, @@nvarchar2@@, @@character@@, @@character varying@@, @@char@@, @@nchar@@, @@name@@, @@longvarchar@@, @@string@@ (deprecated),
  * @@int@@, @@integer@@, @@tinyint@@, @@smallint@@, @@mediumint@@, @@bigint@@, 
  * @@serial@@, @@bigserial@@, @@autoincrement@@, @@bigautoincrement@@,
  * @@double@@, @@double precision@@, @@float@@, @@real@@, @@number@@, @@binary_float@@, @@binary_double@@, @@money@@,
  * @@numeric@@, @@decimal@@, @@dec@@,
  * @@date@@, @@time@@, @@datetime@@, @@timestamp@@, @@utimestamp@@, @@year@@, @@interval@@
  * @@boolean@@, @@bool@@, @@bit@@
  * @@tinytext@@, @@text@@, @@mediumtext@@, @@longtext@@, @@long@@, @@clob@@, @@nclob@@
  * @@tinyblob@@, @@blob@@, @@mediumblob@@, @@longblob@@, @@bfile@@,
  * @@varbinary@@, @@bytea@@, @@binary@@, @@raw@@, @@long raw@@
  * @@enum@@, @@set@@, @@xmltype@@, @@point@@, @@line@@, @@lsed@@, @@box@@, @@path@@, @@polygon@@, @@circle@@, @@cidr@@, @@inet@@, @@macaddr@@, @@bit varyong@@, @@arrays@@, @@complex types@@

Of course, some database doesn't recognize all of these types. Don't worry, jDao
will use the corresponding type in the selected database. For example, @@bytea@@
is a postgresql type. If you use a mysql database, jDao will use @@longblob@@.

Values of fields will be converted in the corresponding PHP type, most of time,
in a string.

For auto-incremented fields, you can indicate @@serial@@ or @@autoincrement@@ as
a type. But for some case, it is better to indicate one of integer types, and to
set a @@A@autoincrement@@ attribute to @@true@@. On some databases, an auto
incremented field can be associated with a sequence. Then the attribute
@@A@sequence@@ should contain the sequence name.

The attribute @@A@comment@@ allow to indicate a comment on the property. This comment
can be used as label for form field, with the createform command.

The attributes @@A@updatepattern@@, @@A@insertpattern@@ and @@A@selectpattern@@
lets you specify a pattern to be applied during the update, the insert or the
read of the field value. This pattern should really be a SQL expression, and can
contain the string "%s", which will be replaced by the value or the name of the
field. Default values of patterns is "%s". If it indicates an empty value, this
corresponds to a null operation (so the field is not readed, inserted or
updated). On primary keys you can use @@A@insertpattern@@ and
@@A@selectpattern@@ , but not @@A@updatepattern@@.

=== Example 1 ===

For a field which contains an updated date, we can do:

<code xml>
  <property name="date_update" datatype="datetime" insertpattern="NOW()" updatepattern="NOW()" />
</code>

So each time there is an insert or an update, the inserted value will be the current date.


=== Example 2 ===

It may also have a property that does not correspond directly to a field, but
that is the result of a SQL expression. In this case, you must disable the
inserting and updating.

<code Xml>
   <property Name="identite" datatype="string" selectpattern="CONCAT(name,' ',firstname)" insertpattern="" updatepattern="" />
</code>

Carefull about the content of @@A@selectpattern@@:

  * Expression must use fields of a single table. If a dao is based on multiple
    tables (for example, A and B, see next section), it is not possible to
    indicate both fields from the table A and the table B in the same
    @@A@selectpattern@@.
  * If the expression uses some fields of the table B (a foreign table), then
    corresponding properties should be declared for this table, with the
    @@A@table@@ attribute on the @@E@<property>@@ element, with the name or
    alias of the table B, as a value.


===== Mapping on several tables =====

We can declare a table, but also additionnal tables which are linked to the main
table by joins. It is useful when you want to retrieve simultaneously a record
and informations of other tables. For example, if you want to retrieve a product
of the "products" table, and at the same time the name of its category from the
table "category", you should also declared the table "category". Note that you
can modify only data which come from the main table when you want to update or
insert a record.

To declare such foreign tables, which are logically related to the main table by
foreign keys, you should use:

   * @@E@<foreigntable>@@ to indicate a foreign table  linked by a normal join.
   * @@E@<optionalforeigntable>@@ to indicate a foreign table linked by an outer join.

Example:

<code xml>
   <primarytable name="p" realname="products" primarykey="id_product" />
   <foreigntable name="cat" realname="categories" primarykey="id_cat" onforeignkey="id_cat" />
   <optionalforeigntable name="man" realname="manufacturers" primarykey="id" onforeignkey="id_manufacturer" />
</code>

As for tag @@E@<primarytable>@@, there are attributes @@A@name@@, @@A@realname@@
and @@A@primarykey@@. There is also an additional attribute,
@@A@<onforeignkey>@@, which indicates the name of the field in the primary
table, which is the foreign key on the table in question. Thus, with the above
example, jDao generate requests for type @@SELECT@@ terms @@FROM@@ and
@@WHERE@@:

<code sql>
 FROM products as p left join manufacturers as man on (p.id_manufacturer = man.id),  categories as cat
 WHERE cat.id_cat = p.id_cat
</code>


You can add @@E@<property>@@ element to map properties to field of foreign
tables, like any other property for the main table. The only difference is that
you have to add an attribute @@A@table@@ which indicates the alias of the table
in which the field belongs to.

<code xml>
  <property 
      name="category_label" 
      fieldname="label" 
      table="cat"
   />
</code>


===== Using a PHP class for records =====

You would want to have methods and additional properties on the
record object generated by jDao. This is possible by providing your
own class, which will inherits from @@C@jDaoRecordBase@@, and will be inherited
by the generated class.

**Warning**: this class does not suppose to do SQL request on the table of the DAO.
Your methods should only do some calculation, verify some business rules etc.. If you want
to do SQL request, see "XML or PHP methods" on the DAO factory.. 

Your class must be stored into the @@F@daos/@@ directory, and it must follow a specific class naming.

However, since Jelix 1.8.1, you can also store your class in the directory you want, but it should be autoloadable.

==== The class is into @@F@daos/@@ ====

Your class have the name you want, with the suffix @@DaoRecord@@, and
it should be stored into the directory @@F@daos/@@ of a module, in the file
@@<classname>.daorecord.php@@.

You indicate the class selector  @@<modulename>~<classname>@@ in the @@A@extends@@ attribute
on the @@E@<record>@@ element.

Note that your class should inherit from @@C@jDaoRecordBase@@.

Example, in your dao file:

<code xml>
   <record extends="news~news">
   ...
   </record>
</code>

Records will be objects from the class @@C@newsDaoRecord@@ stored in the file
@@F@daos/news.daorecord.php@@ in the module @@news@@.

<code php>
class newsDaoRecord extends jDaoRecordBase {

   function calculateSomething() {
        $this->field1 = $this->field2 * 1.196;
   }

   function calculateTotal() {
      return $this->amount + $this->vat;
   }
}
</code>


Then you can call this method on each records:

<code php>

   $maFactory = jDao::get("mymodule~news");
   $list = $maFactory->findAll();

   foreach ($list as $row) {
        $total = $row->calculateTotal();
        //...
   }
</code>

==== The class is autoloadable ====


If your class has a namespace and is autoloadable,
you should then indicate its full name into the @@A@extends@@ attribute
on the @@E@<record>@@ element.

The class should inherit from @@C@jDaoRecordBase@@.

Example, in your dao file:

<code xml>
   <record extends="\MyCompany\MyDomain\News">
   ...
   </record>
</code>

Records will be objects from the class @@C@\MyCompany\MyDomain\News@@ stored in a file
@@F@News.php@@ somewhere. Here is an example of source code:

<code php>
class \MyCompany\MyDomain\News extends \jDaoRecordBase {

   function calculateSomething() {
        $this->field1 = $this->field2 * 1.196;
   }

   function calculateTotal() {
      return $this->amount + $this->vat;
   }
}
</code>


Then you can call this method on each records:

<code php>

   $maFactory = jDao::get("mymodule~news");
   $list = $maFactory->findAll();

   foreach ($list as $row) {
        $total = $row->calculateTotal();
        //...
   }
</code>




===== Importing an other dao =====

In your project, you'll need some time to create a dao that have the same
content that an other one, with additionnal properties or methods.

To avoid to rewrite all datasources/properties/methods, you can //import//
a dao, and write only new properties or methods. You do that by adding
an attribute @@A@import@@ on the @@E@dao@@ element.

==== How it works ====

   * The DAO to import is readed first, so your dao will contain all of
     its datasource, properties or methods.
   * Then your dao is readed. All of its datasource, properties or methods
     are added or overwrite existing properties/methods
   * The PHP class is then generated

Note that an import is **not** an inheriting as in PHP.

Example:

A good is example is jauthdb: if you need to define your own DAO, documentation says
that //"it must have at least the same properties and methods defined into the jelixuser dao"//.

So, importing the dao of jauthdb into your own dao is a good thing:

<code xml>
<dao import="jauthdb~jelixuser">
	<datasources>
		<primarytable name="user" realname="myusertable" primarykey="login" />
	</datasources>
	<record>
		<property name="nationality" fieldname="nationality" datatype="string" maxlength="100" required="true">
	</record>
	<factory>
		<method name="findByNationality" type="select">
			<parameter name="nationality" />
			<conditions>
				<eq property="nationality" expr="$nationality" />
			</conditions>
		</method>
	</factory>
</dao>
</code>

Here you'll have a dao with same properties and methods than "jauthdb~jelixuser"
(@@P@password@@, @@M@getByLoginPassword@@, @@M@getByLogin@@...)
with this additionnal @@P@nationality@@ property and @@M@findByNationality()@@ method.
