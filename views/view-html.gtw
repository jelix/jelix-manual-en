~~LANG:FR@frman:vues/vue-html~~


To generate HTML/XHTML, you indicate the alias "html" or "basichtml" to the
@@M@getResponse()@@ method in your controller's action. Then you retrieve
respectively an instance of @@C@jResponseHtml@@ or @@C@jResponseBasicHtml@@.
Here is an example:

<code php>
   $resp = $this->getResponse('html')
</code>

===== HTML5 ou HTML4 =====

Since Jelix 1.5, @@C@jResponseHtml@@ generates an HTML5 header instead of an
HTML4 header. However, you may want to have HTML4 as in previous versions. You
should then use the class @@C@jResponseHtml4@@.

So, if you have a [[personnalized-common-response|personnalized response]]
(this is the case by default in new applications), you should inherit from
@@C@jResponseHtml4@@ instead of @@C@jResponseHtml@@:

<code php>
require_once (JELIX_LIB_CORE_PATH.'response/jResponseHtml4.class.php');

class myHtmlResponse extends jResponseHtml4 {

}
</code>

Note: @@C@jResponseHtml4@@ inherits from @@C@jResponseHtml@@, so, in following
parts of the manual, all features described for @@C@jResponseHtml@@ are
available for @@C@jResponseHtml4@@.


===== XTHML or HTML =====

@@C@jResponseHtml@@ and @@C@jResponseHtml4@@ classes have an XHTML mode.
Anyway, as in all previous jelix versions ( <= 1.4), @@C@jResponseHtml4@@
generates XHTML headers. 


The  @@M@setXhtmlOutput()@@ of this classes allows to generate the right
DOCTYPE and HTTP headers according to your preferences:

<code php>
// jResponseHtml
$rep->setXhtmlOutput(true);  // XHTML 5
$rep->setXhtmlOutput(false); // HTML 5 (par défaut)

// jResponseHtml4
$rep->setXhtmlOutput(true);  // XHTML 1.0 (par défaut)
$rep->setXhtmlOutput(false); // HTML 4

// Fetch the setting value :
$outputXhtml = $this->isXhtml();
</code>

Going further, you can specify your own DOCTYPE by overloading
@@M@outputDocType()@@ (using jResponseHtml, not jResponseBasicHtml). This method
should echo a valid DOCTYPE.

The XHTML mode is also available with @@C@jResponseBasicHtml@@, but it will
influence only HTTP headers. You should modify your template to indicate
the right doctype.

===== Returning the content of a static page =====

@@C@jResponseBasicHtml@@ allows to return simply a static page stored in a file.
This file should be a simple PHP file, and not a template for jTpl. It should
contain all the HTML code of a page, and three instructions to display these
variables:

    * @@V@$HEADTOP@@ : after the opening tag @@E@<head>@@
    * @@V@$HEADBOTTOM@@ : before the end tag @@E@</head>@@
    * @@V@$BODYTOP@@ : after the opening tag @@E@<body>@@
    * @@V@$BODYBOTTOM@@ : before the end tag @@E@</body>@@

These variables contain HTML code given by the call of methods
@@M@addHeadContent()@@ and @@M@addContent()@@ of the object
@@C@jResponseBasicHtml@@. These calls may be made by some components like
controllers, classes, plugins... So you really should include these
instructions.

There is also an other variable,  @@V@$BASEPATH@@ (since Jelix 1.4.1), containing
the base path of the application, and that could be useful for your style sheets
or other static resources.

Here is an example of a such static file: 

<code html>
<!DOCTYPE html>
<html lang="en_US">
  <head>
     <?php echo $HEADTOP; ?>
     <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
      <title>Hello From Jelix !</title>
      <link type="text/css" href="<?php echo $BASEPATH; ?>mystyles.css" rel="stylesheet" />
      <?php echo $HEADBOTTOM; ?>
  </head>
  <body>
      <?php echo $BODYTOP; ?>
     <h1>Hello YOU !</h1>
     <p>This is a sample html page generated by Jelix</p>
      <?php echo $BODYBOTTOM; ?>
  </body>
</html>
</code>

In your controller, you must indicate where can @@C@jResponseBasicHtml@@ find
this file, by giving its full path in the property @@P@$htmlFile@@. Note that
the object @@C@jCoordinator@@ owns a method allowing to retrieve the path of a
module. So it is easy to give the path of a file stored in a module.

<code php>
   $rep = $this->getResponse('basichtml');
   $rep->htmlFile = jApp::coord()->getModulePath('unModule'). 'static/hello.php';
</code>


===== Generating dynamic contents =====

To return dynamic content, you have to use the class @@C@jResponseHtml@@,
corresponding to the response type "html". This class implements additionnal
methods and properties to manipulate the HTML/XHTML content. So it is more
flexible for all consumers components (zones, templates, controllers..).

The source of an HTML page is split into two parts: the @@E@<head>@@ part, and
the @@E@<body>@@ part.

{{jresponsehtml_step1.png|}}

jResponseHTML generates itself the content of the @@E@<head>@@ element, from
data you give to the jResponseHTML via its dedicated methods. However, you are
responsible of the generation of the content of the @@E@<body>@@ element. Let's
see all of these things.


==== Generating (X)HTML headers ====

jResponseHtml provides features to change document's title, favicon, links to
style sheets or JS scripts, meta tags...

Features tour:

<code php>

$resp->title = 'Document Title';

// generate a script tag
$resp->addJSLink( '/lib.js' );

// generate a script tag with inline code :
$resp->addJSCode( 'alert( "Hello world" ) )' );

// generate a <link>
$resp->addCSSLink('/style.css');

// generate a <style>
$resp->addStyle('span', 'font-weight:bold;');

// Add a description meta tag:
$resp->addMetaDescription( 'description' );

// Add a keywords meta tag:
$resp->addMetaKeywords( 'jelix php framework' );

// Add the author:
$resp->addMetaAuthor('Laurent');

// change the meta generator name
$resp->addMetaGenerator('My Super App 1.0');

// set the compatibility mode for IE (since 1.6.17)
$resp->IECompatibilityMode = 'IE=Edge'; // value by default in Jelix 1.7

// set the viewport (since 1.6.17)
$resp->metaViewport = 'width=device-width, initial-scale=1.0';

// add a meta element (since 1.6.17)
$resp->addMeta(array('name'=>'apple-touch-fullscreen', 'content'=>'yes'));

</code>

If you want to add custom content in the @@E@<head>@@ element, use @@M@addHeadContent()@@:

<code php>
$resp->addHeadContent('<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="/feed.php" />')
</code>

It happens to require removal of parts of the generated headers (if you refuse
to take the hand on third-party-module). You should use method
@@M@clearHtmlHeader()@@ for this:

<code php>
// remove links to stylesheets done with addCSSLink(), and style tags from addStyle()
$resp->clearHtmlHeader( array( 'CSSLink', 'Styles' ) );
</code>

Acceptable array values are strings @@'CSSLink'@@, @@'Styles'@@, @@'JSLink'@@, @@'JSCode'@@, @@'Other'@@.

==== Generate (X)HTML body ====

jResponseHtml generates the (X)HTML @@E@<body>@@ tag, but you must control its
contents and attributes.

To control its attributes:

<code php>
$resp->bodyTagAttributes = array( 'onload'=>'bodyonload( )',
                                   'class'=>'maincontent');
</code>

Control its contents with either:
  * a template
  * method @@M@addContent( )@@

=== Using a template ===

jResponseHtml provides a couple of properties:
  * @@P@$bodyTpl@@, which value should be the template selector;
  * @@P@body@@, which contains a jTpl instance allowing control over template "settings".

For example :
<code php>
$resp->bodyTpl = 'myapp~main';
$resp->body->assign( 'person','Guybrush Treepwood');
</code>

Contents generated by the template engine will be integrated in the (X)HTML body
tags automatically.

To know more about templates, read [[/templates|chapter about templates]].

It happens to require appending some arbitrary contents in addition to the
(X)HTML body code generated with method @@M@addContent()@@:

  * first argument is the string value to append to the (X)HTML body contents,
  * second argument is a bool about the order :
    * @@L@true@@ if the first argument's string value should be placed before the template
    * @@L@false@@ if it should be placed after the template.

Note that it's set to false by default. 

Example:
<code php>
$resp->addContent( 'This text will be placed after the template' );
$resp->addContent( 'This text will be placed before the template', true);
</code>

It's possible to use this method to append contents from "zones", for example:
<code php>
$resp->addContent( jZone::get( 'aModule~aZone'));
</code>



=== Using a main template and some "sub-templates" ===

We often have a common template for all pages, and only few things change inside
this common template, depending of the page. So you will have a first template
for the common things, and all pages will define an other "sub-template" to
generate specific things for the page. The result of this sub-template will be
inserted into the main template.

You can do this work directly into all your controllers, with zones. 

But there is a more convenient way to do it: you can define an object which
inherits from jResponseHtml. In this object, you will define all common things.
And then you declare this object as the default HTML view for all your actions.

Read the section: [[/common-processes#customizing-common-response|how to create a custom common response]].


=== Not using templates ===

Let @@P@bodyTpl@@ empty if you don't want to use a template for the (X)HTML body
of the response, and use @@M@addContents()@@ as described in the previous
paragraph of the documentation.

<code php>
$rep->addContent('<p>content for my body</p>');
</code>


==== Adding CSS style sheets, javascript files, images... ====

You probably saw above an example about the use of @@M@addJSLink()@@ and
@@M@addCSSLink()@@. These methods allow you to link some CSS style sheets and
javascript files to your HTML page.

@@M@addJSLink()@@ and @@M@addCSSLink()@@ accept as first argument the URL of a
JS file or CSS file. Since most of URL of your application are "virtual" (the URL of
"actions" do not corresponds to a static file), you cannot indicate an URL for your CSS/JS
files,  relative to the URL page (except if you really know what you do,
but it will not be very easy). You should then indicate an absolute URL (most of
time without the domain name).

Your CSS/JS files can be stored into the www/ directory of your application or in the www/ directory of a module.

If it is stored into the www/ directory of your application, and if this directory
in the "documentRoot" of the application, then just indicate its path with a leading @@/@@.
For instance, if you want to link to @@F@yourapp/www/css/mystyles.css@@, then you should do:

<code php>
  $resp->addCSSLink('/css/mystyles.css');
</code>

However, if @@F@www/@@ is not the document root, or if your module is supposed to be
used by other applications, or if the application can be installed in some different
configuration, it is better to add the "base path" of the web site:

<code php>
  $resp->addCSSLink(jApp::config()->urlengine['basepath'].'css/mystyles.css');
</code>

If you want a link to a CSS/JS file of the @@F@lib/jelix-www/@@ directory, you
can use the @@jelixWWWPath@@ property:

<code php>
  $resp->addJSLink(jApp::config()->urlengine['jelixWWWPath'].'js/tooltip.js');
</code>

If the CSS/JS file is stored into a module, then you should use
@@M@addJSLinkModule()@@ or @@M@addCSSLinkModule()@@. Arguments to these methods
are the module name, the path of the resource inside the www/ directory of the module.


For example, if you want a link to the file @@F@mymodule/www/css/mystyles.css@@:

<code php>
  $resp->addCSSLinkModule('mymodule', 'css/mystyles.css');
</code>


Note that @@M@addCSSLink()@@, @@M@addJSLink()@@, @@M@addJSLinkModule()@@ and
@@M@addCSSLinkModule()@@ can use an associative array argument specifying custom
(X)HTML tag properties, for example:

<code php>
$resp->addCSSLink( 
    '/stylesheet.css', 
    array( 
        'title' => 'blue design',
        'rel'   => 'alternate stylesheet',
    )
);
</code>

All previous example about the retrieval of URLs of CSS files, work with JS
files, images files and any other ressources stored into the @@F@www/@@
directory of an application, a module or into the jelix-www directory.

You can also use same principle directly in a template:

<code smarty>
  {* in the www/ of the application *}
  {meta_html css '/css/mystyles.css'}
  {meta_html css $j_basepath.'css/mystyles.css'}
  
  {* in the jelix-www/ *}
  {meta_html js  $j_jelixwww.'js/tooltip.js'}

  {* in the www/ of a module *}
  {meta_htmlmodule css 'mymodule', 'css/mystyles.css'}

  {* link to an image into myapp/mymodule/www/img/mypicture.png *}  
  <img src="{jurl 'jelix~www:getfile', array('targetmodule=>'mymodule', 'file'=>'img/mypicture.png')}" />
</code>

See [[/templates|chapter about templates]] to know more about these features.

===== Other response parameters =====

It's possible to control HTTP headers since jResponseHtml and jResponseBasicHtml
inherit from jResponse, for the status code as well as for miscellaneous
properties.

<code php>
$resp->setHttpStatus( '404', 'Not Found' );
$resp->addHttpHeader( 'Date-modified', '...' );
</code>

If jResponseHtml's property @@P@$xhtmlContentType@@ is true: HTTP response's
"Content-Type" will be @@application/xhtml+xml@@. Note that the client-browser
must support xHTML, or Content-Type @@text/html@@ is sent.

<code php>
$resp->xhtmlContentType = true ;
</code>

===== Using plugins =====

@@C@jResponseHtml@@ and @@C@jResponseBasicHtml@@ have a plugin system. These
plugins allow to add content or modify the response content automatically, on
all HTML pages generated with these classes. Thus there is such plugins to show
a debug bar, or to "minify" css style sheets or javascript files.

These plugins have the plugin type "htmlresponse", so they have to be stored in
a @@F@htmlresponse/@@ directory inside a plugins repository. To activate them,
you need to specify their name in the option @@plugins@@ in the section
@@jResponseHtml@@ of the main configuration. Example:

<code ini>
[jResponseHtml]
plugins = debugbar, minify
</code>

==== Minifying css and javascript files ====

Jelix provides [[http://code.google.com/p/minify/|Minify]], which allow to
concatenate and minify CSS and JS files. It improves performance during the load
of the page.

To activate the plugin "minify", put its name into the @@plugins@@ option as
indicated in the previous section. You have then some configuration options.

<code ini>
[jResponseHtml]

;concatenate and minify CSS and/or JS files :
minifyCSS = off # [on|off] : concatenate/minify CSS files
minifyJS = off # [on|off] : concatenate/minify JS files

; list of filenames (no path) which shouldn't be minified - coma separated :
minifyExcludeCSS = "file1.css,file2.css"
minifyExcludeJS = "jelix/wymeditor/jquery.wymeditor.js"

; bootstrap file for Minify. indicate a relative path to the basePath.
minifyEntryPoint = minify.php
</code>

First, with @@minifyCSS@@ and @@minifyJS@@ you activate the "minification". You
can indicate files to **NOT** minify in @@minifyExcludeCSS@@ and
@@minifyExcludeJS@@. Keep the file name @@F@jelix/wymeditor/jquery.wymeditor.js@@ in
@@minifyExcludeJS@@. Wymeditor doesn't like to be concatenated with other files.

Indicated path should be
    * relative to the base path of the application (without a leading /)
    * or relative to the domain name (with a leading /)

Don't indicate full URL (with @@http://@@...), they are automatically excluded.

Second, you have to install a script @@F@minify.php@@ in @@F@www/@@. Simply copy
the file @@F@lib/jelix-scripts/templates/www/minify.php.tpl@@ into
@@F@votre_appli/www/minify.php@@. There are some options in this file you can
set to configure Minify (read the documentation of Minify). If you want to
choose an other name for this script, indicate its name into the option
@@minifyEntryPoint@@.



 ; list of filenames (no path) which shouldn't be minified - coma separated :
 minifyExcludeCSS = "file1.css,file2.css"
-minifyExcludeJS = "jquery.wymeditor.js"
+minifyExcludeJS = "jelix/wymeditor/jquery.wymeditor.js"
 
 ; bootstrap file for Minify. indicate a relative path to the basePath.
 minifyEntryPoint = minify.php
 </code>
 

